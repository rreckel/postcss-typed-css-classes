var os = require('os');

module.exports = {
  generate: generate
};

/*
 * Example classes:
  [
    {
      "name": "container",
      "properties": [
        {
            "property": "max-width: 576px",
            "mediaQuery": "@media (min-width: 576px)"
        },
        {
            "property": "max-width: 768px",
            "mediaQuery": "@media (min-width: 768px)"
        }
      ]
    }
  ]
*/

// Generate a scala object containing the CSS classes
// - see EXAMPLE CODE:
//     `/tests/scala_generator_test/scala_generator.basic.expected_output`
function generate (classes) {

  classes = addObjectName(classes);
  let objects = createObjects(classes);
  
  return (
    os.EOL +
      generateWarning() +
      os.EOL +
      generateCSSObjects(objects) +
      os.EOL
  );
}

function generateWarning () {
  return "// DO NOT EDIT THIS FILE - IT'S GENERATED, CHANGES WILL BE LOST!" + os.EOL +
    'package css' + os.EOL;
}

function generateCSSObjects(objects) {
  return (
    objects.map(generateCSSObject).join('')
  );
}

function generateCSSObject(object) {
  if(object.name == '') {
    objName = 'CSS';
  } else {
    objName = 'CSS_' + escapeClassName(object.name);
  }
  return (
    'object ' + objName + ' {' + os.EOL +
      generateCSSClasses(object.classes) +
      '}' + os.EOL    
  )
}

function generateCSSClasses(classes) {
  return (
    classes.map(generateCSSVal).join('')
  );
}

function generateCSSVal(class_) {
  return (
    '  val ' + class_.escapedName + ' = "' + class_.name + '"' + os.EOL
  );
}

function addObjectName(classes) {
  return classes.map(function (class_) {
    let n = class_.name.lastIndexOf(':');
    if(n == -1) {
      class_.objectName = "";
      class_.escapedName = escapeClassName(class_.name);
    } else {
      class_.objectName = class_.name.slice(0, n);
      class_.escapedName = escapeClassName(class_.name.slice(n+1));
    }
    return class_
  })
}

function createObjects(classes) {
  let objects = [];
  classes.forEach(function(class_) {
    let index = findObjectIndex(
      objects,
      class_.objectName
    );
    if(index !== null) {
      objects[index].classes.push(class_)      
    } else {
      objects.push({
        name: class_.objectName,
        classes: [class_]
      })
    }
  })
  return objects;
}

function findObjectIndex (
  objects, objectName
) {
  for (let [i, element] of objects.entries()) {
    if (element.name === objectName) {
      return i
    }
  }
  return null
}

function addEscapedNames (classes) {
  return classes.map(function (class_) {
    class_.escapedName = escapeClassName(class_.name)
    return class_
  })
}

// Rust doesn't allow to use any string as a field name
function escapeClassName (name) {
  name = name.replace(/-/g, '_')
  name = name.replace(/:/g, '_')
  name = name.replace(/\./g, 'p')
  name = name.replace(/\//g, 'of')
  if (getKeywords().indexOf(name) > -1) {
    name += '_'
  }
  return name
}

function getKeywords () {
  return [];
}
